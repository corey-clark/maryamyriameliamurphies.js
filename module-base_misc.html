<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Module: base/misc</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Module: base/misc</h1>

    




<section>

<header>
    
        
    
</header>

<article>
    <div class="container-overview">
    
        

        
    
    </div>

    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".$"><span class="type-signature">(static) </span>$<span class="signature">(f)</span><span class="type-signature"> &rarr; {function|*}</span></h4>

    



<div class="description">
    <p>Compose two functions. In Haskell, f.g = \x -&gt; f(g x), or the composition of two functions f and
f and g is the same as applying the result of g to f, or f(g(x)) for a given argument x. This
pattern can't exactly be reproduced in JavaScript, since the dot operator denotes namespace
membership, and custom operators are not available. Haskell also provides the $ operator,
however, which simply binds functions right to left, allowing parentheses to be omitted:
f $ g $ h x = f (g (h x)). We still can't do this in JavaScript, but why not borrow the $ for the
sake of at least some semantic consistency? Sorry, jQuery. This function takes a function <code>f</code> as
an argument and returns a new closure that takes another function <code>g</code> and a single argument <code>x</code>.
This function will not work as expected if you pass in two arguments. Note that an argument need
not be supplied to the rightmost function <code>g</code>, in which case <code>$</code> returns a new function to which
you can bind an argument later. The leftmost function <code>f</code>, however, must be a pure function, as
its argument is the value returned by the rightmost function (though, for <code>f</code>, you can use a
function with all but one of its arguments partially applied).
<br><code>Haskell&gt; (.) :: (b -&gt; c) -&gt; (a -&gt; b) -&gt; a -&gt; c</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The outermost function to compose</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="base_misc.js.html">base/misc.js</a>, <a href="base_misc.js.html#line82">line 82</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The composed function or its final value if a value is bound to f</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>
|

<span class="param-type">*</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const addTen = x => x + 10;
const multHund = x => x * 100;
const addTwenty = x => addTen(10);
const h = (x, y) => {
  const p = (x, y) => x / y;
  return partial(p, x, y);
}
const divByTen = h(10);
$(addTen)(multHund)(10);   // => 1010
$(addTen)(multHund, 10);   // => 1010
$(multHund)(addTen)(10);   // => 2000
$(multHund)(addTen, 10);   // => 2000
$(addTen)(addTwenty)();    // => 30
$(divByTen)(multHund)(10); // => 0.01
}</code></pre>



        
            

    

    <h4 class="name" id=".constant"><span class="type-signature">(static) </span>constant<span class="signature">(a, b)</span><span class="type-signature"> &rarr; {*}</span></h4>

    



<div class="description">
    <p>Return the value of the first argument, throwing away the value of the second argument.
<br><code>Haskell&gt; const :: a -&gt; b -&gt; a</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>Any object</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>b</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>Any object</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="base_misc.js.html">base/misc.js</a>, <a href="base_misc.js.html#line124">line 124</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>a - The value of the first object</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>constant(2, 3);                                  // => 2
const multHund = x => x * 100;
const c = (x, y) => $(constant(x))(multHund)(y);
c(5, 10);                                        // => 5</code></pre>



        
            

    

    <h4 class="name" id=".flip"><span class="type-signature">(static) </span>flip<span class="signature">(f)</span><span class="type-signature"> &rarr; {function}</span></h4>

    



<div class="description">
    <p>Reverse the order in which arguments are applied to a function. Note that <code>flip</code> only works on
binary functions, which take exactly two arguments, but the function it returns is curried.
<br><code>Haskell&gt; flip :: (a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The function to flip</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="base_misc.js.html">base/misc.js</a>, <a href="base_misc.js.html#line97">line 97</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The function with its arguments reversed</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const subtract = (x, y) => x - y;
const flipped = flip(subtract);
subtract(10, 5);                  // => 5
flipped(10, 5);                   // => -5</code></pre>



        
            

    

    <h4 class="name" id=".id"><span class="type-signature">(static) </span>id<span class="signature">(a)</span><span class="type-signature"> &rarr; {*}</span></h4>

    



<div class="description">
    <p>Return an argument value unchanged. This is the identity function.
<br><code>Haskell&gt; id :: a -&gt; a</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>a</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>Any object</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="base_misc.js.html">base/misc.js</a>, <a href="base_misc.js.html#line109">line 109</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>a - The same object</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>id(1);           // => 1
id(list(1,2,3)); // => [1:2:3:[]]</code></pre>



        
            

    

    <h4 class="name" id=".partial"><span class="type-signature">(static) </span>partial<span class="signature">(f)</span><span class="type-signature"> &rarr; {function|*}</span></h4>

    



<div class="description">
    <p>Partially apply arguments to a given function. Accepts a function and a variable number of
arguments. If all the arguments are applied, call the function and return its value. Otherwise,
return a new function bound by whichever values have already been applied. In Haskell, all
functions technically bind one argument and return one value. Functions that take multiple
arguments are actually &quot;curried&quot; under the hood, therefore such a function actually returns
another function with its first argument bound, then another with its second, and so on until all
expected arguments have been bound. Likewise, almost every function in this library that accepts
multiple arguments is similarly curried, so you can partially apply arguments to almost any
function and pass that value around as an argument to another function. Note that <code>partial</code>
itself cannot be partially applied.</p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The function to partially apply</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>{...*)</code></td>
            

            <td class="type">
            
            </td>

            

            

            <td class="description last"><p>as - The values expected as arguments</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="base_misc.js.html">base/misc.js</a>, <a href="base_misc.js.html#line39">line 39</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new function with its arguments partially or fully applied</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">function</span>
|

<span class="param-type">*</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>function multiply(x, y) {
  // create a closure with the same arguments and "do the math" in this closure
  const multiply_ = (x, y) => x * y;
  // return a "curried" version of the function that accepts partial application
  return partial(multiply_, x, y);
}
multiply(10, 10); // => 100
multiply(10);     // => function () { [native code] } // (with 10 applied to x)
multiply(10)(10); // => 100</code></pre>



        
            

    

    <h4 class="name" id=".until"><span class="type-signature">(static) </span>until<span class="signature">(p, f, x)</span><span class="type-signature"> &rarr; {*}</span></h4>

    



<div class="description">
    <p>Yield the result of applying function <code>f</code> to a value <code>x</code> until the predicate function <code>p</code> is
true. A negative, recursive version of a <code>while</code> loop.
<br><code>Haskell&gt; until :: (a -&gt; Bool) -&gt; (a -&gt; a) -&gt; a -&gt; a</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>p</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>A predicate function that returns a boolean</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The function to apply to <code>x</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>x</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The value to bind to <code>f</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="base_misc.js.html">base/misc.js</a>, <a href="base_misc.js.html#line144">line 144</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The result of applying <code>f</code> to <code>x</code> until <code>p</code> returns <code>true</code></p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">*</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const p = x => x > 10;
const f = x => x + 1;
const u = until(p, f);
u(1);                  // => 11</code></pre>



        
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-applicative.html">applicative</a></li><li><a href="module-base_bool.html">base/bool</a></li><li><a href="module-base_io.html">base/io</a></li><li><a href="module-base_misc.html">base/misc</a></li><li><a href="module-base_num.html">base/num</a></li><li><a href="module-eq.html">eq</a></li><li><a href="module-error.html">error</a></li><li><a href="module-foldable.html">foldable</a></li><li><a href="module-functor.html">functor</a></li><li><a href="module-list_building.html">list/building</a></li><li><a href="module-list_folds.html">list/folds</a></li><li><a href="module-list_func.html">list/func</a></li><li><a href="module-list_indexing.html">list/indexing</a></li><li><a href="module-list_inf.html">list/inf</a></li><li><a href="module-list_reducing.html">list/reducing</a></li><li><a href="module-list_searching.html">list/searching</a></li><li><a href="module-list_set.html">list/set</a></li><li><a href="module-list_sub.html">list/sub</a></li><li><a href="module-list_trans.html">list/trans</a></li><li><a href="module-list_zip.html">list/zip</a></li><li><a href="module-maybe_func.html">maybe/func</a></li><li><a href="module-monad.html">monad</a></li><li><a href="module-monoid.html">monoid</a></li><li><a href="module-ord.html">ord</a></li><li><a href="module-traversable.html">traversable</a></li><li><a href="module-tuple_func.html">tuple/func</a></li><li><a href="module-type.html">type</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Jul 21 2016 17:04:18 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>