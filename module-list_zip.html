<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Module: list/zip</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Module: list/zip</h1>

    




<section>

<header>
    
        
    
</header>

<article>
    <div class="container-overview">
    
        

        
    
    </div>

    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".insert"><span class="type-signature">(static) </span>insert<span class="signature">(e, xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>The <code>insert</code> function takes an element and a <code>List</code> and inserts the element into the list at the
first position where it is less than or equal to the next element. In particular, if the list is
sorted before the call, the result will also be sorted. Use <code>insertBy</code> to supply your own
comparison function.
<br><code>Haskell&gt; insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>e</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The element to insert</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to insert into</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line174">line 174</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new <code>List</code>, with the element inserted</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst = list(1,2,3,4,5,6,8,9,10);
insert(7, lst); // => [1:2:3:4:5:6:7:8:9:10:[]]</code></pre>



        
            

    

    <h4 class="name" id=".insertBy"><span class="type-signature">(static) </span>insertBy<span class="signature">(cmp, e, as)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Insert an element into a list using a comparison function of your choice.
<br><code>Haskell&gt; insertBy :: (a -&gt; a -&gt; Ordering) -&gt; a -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>cmp</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The comparison function—must return an <code>Ordering</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>e</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The element to insert</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to insert into</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line192">line 192</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new <code>List</code>, with the element inserted</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const notCompare = (x, y) => compare(x, y) === EQ ? EQ : (GT ? LT : GT);
const lst = list(1,2,3,4,5,6,8,9,10);
insertBy(notCompare, 7, lst); // => [7:1:2:3:4:5:6:8:9:10:[]]</code></pre>



        
            

    

    <h4 class="name" id=".mergeSort"><span class="type-signature">(static) </span>mergeSort<span class="signature">(xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using regular value comparison. Use <code>mergeSortBy</code> to supply your own comparison
function. Uses a merge sort algorithm, which may be more efficient than <code>sort</code> for larger lists.
<br><code>Haskell&gt; sort :: Ord a =&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line86">line 86</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <ul>
<li>The sorted <code>List</code> (the original list is unmodified)</li>
</ul>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(20,19,18,17,16,15,14,13,12,11,10,1,2,3,4,5,6,7,8,9);
mergeSort(lst1); // => [1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:[]]
const f = x => x + 1;
const lst2 = reverse(listRange(1, 11, f)); // [10:9:8:7:6:5:4:3:2:1:[]]
mergeSort(lst2);                           // => [1:2:3:4:5:6:7:8:9:10:[]]</code></pre>



        
            

    

    <h4 class="name" id=".mergeSortBy"><span class="type-signature">(static) </span>mergeSortBy<span class="signature">(cmp, as)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using a comparison function of your choice. Uses a merge sort algorithm, which may be
more efficient than <code>sortBy</code> for larger lists.
<br><code>Haskell&gt; sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>cmp</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The comparison function—must return an <code>Ordering</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line104">line 104</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The sorted <code>List</code> (the original list is unmodified)</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const notCompare = (x, y) => compare(x, y) === EQ ? EQ : (GT ? LT : GT);
const lst1 = listRange(1, 11);
const lst2 = reverse(lst1);    // [10:9:8:7:6:5:4:3:2:1:[]]
mergeSortBy(notCompare, lst1); // => [1:2:3:4:5:6:7:8:9:10:[]]
mergeSortBy(notCompare, lst2); // => [10:9:8:7:6:5:4:3:2:1:[]]</code></pre>



        
            

    

    <h4 class="name" id=".sort"><span class="type-signature">(static) </span>sort<span class="signature">(xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using regular value comparison. Use <code>sortBy</code> to supply your own comparison function.
Uses an insertion sort algorithm. The <code>mergeSort</code> function is probably more efficient for larger
lists.
<br><code>Haskell&gt; sort :: Ord a =&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line49">line 49</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The sorted <code>List</code> (the original list is unmodified)</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst = list(9,8,7,6,5,4,3,10,13,11,14,23,24,26,25,2,1);
sort(lst); // => [1:2:3:4:5:6:7:8:9:10:11:13:14:23:24:25:26:[]]</code></pre>



        
            

    

    <h4 class="name" id=".sortBy"><span class="type-signature">(static) </span>sortBy<span class="signature">(cmp, xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using a comparison function of your choice. Uses an insertion sort algorithm. The
<code>mergeSortBy</code> function is probably more efficient for larger lists.
<br><code>Haskell&gt; sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>cmp</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The comparison function—must return an <code>Ordering</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line66">line 66</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The sorted <code>List</code> (the original list is unmodified)</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const notCompare = (x, y) => compare(x, y) === EQ ? EQ : (GT ? LT : GT);
const lst1 = listRange(1, 11);
const lst2 = reverse(lst1);    // [10:9:8:7:6:5:4:3:2:1:[]]
sortBy(notCompare, lst1);      // => [1:2:3:4:5:6:7:8:9:10:[]]
sortBy(notCompare, lst2);      // => [10:9:8:7:6:5:4:3:2:1:[]]</code></pre>



        
            

    

    <h4 class="name" id=".zip"><span class="type-signature">(static) </span>zip<span class="signature">(as, bs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Take two <code>List</code> objects and return a <code>List</code> of corresponding pairs. If one input list is shorter,
excess elements of the longer list are discarded.
<br><code>Haskell&gt; zip :: [a] -&gt; [b] -&gt; [(a, b)]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line41">line 41</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code> of <code>Tuple</code> objects</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
zip(lst1, lst2);              // => [(1,5):(2,4):(3,3):(4,2):(5,1):[]]</code></pre>



        
            

    

    <h4 class="name" id=".zip3"><span class="type-signature">(static) </span>zip3<span class="signature">(as, bs, cs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Take three <code>List</code> objects and return a <code>List</code> of triples (<code>Tuple</code> objects with three values).
Analogous to the <code>zip</code> function.
<br><code>Haskell&gt; zip3 :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>cs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The third <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line71">line 71</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code> of <code>Tuple</code> objects</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
const lst3 = list(6,7,8,9,10);
zip3(lst1, lst2, lst3);        // => [(1,5,6):(2,4,7):(3,3,8):(4,2,9):(5,1,10):[]]</code></pre>



        
            

    

    <h4 class="name" id=".zipWith"><span class="type-signature">(static) </span>zipWith<span class="signature">(f, as, bs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>A generalization of the <code>zip</code> function. Zip two <code>List</code> objects using a provided function.
<br><code>Haskell&gt; zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The zipping function</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line104">line 104</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code></p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
const f = (x, y) => tuple(x * 3, y ** 2);
const g = (x, y) => x + y;
zipWith(f, lst1, lst2);                   // => [(3,25):(6,16):(9,9):(12,4):(15,1):[]]
zipWith(g, lst1, lst2);                   // => [6:6:6:6:6:[]]</code></pre>



        
            

    

    <h4 class="name" id=".zipWith3"><span class="type-signature">(static) </span>zipWith3<span class="signature">(f, as, bs, cs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>A generalization of the <code>zip3</code> function. Zip three <code>List</code> objects using a provided function.
<br><code>Haskell&gt; zipWith3 :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The zipping function</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>cs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The third <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line136">line 136</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code></p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
const lst3 = list(6,7,8,9,10);
const f = (x, y, z) => tuple(x * 3, y * y, z % 2);
const g = (x, y, z) => x + y + z;
zipWith3(f, lst1, lst2, lst3);    // => [(3,25,0):(6,16,1):(9,9,0):(12,4,1):(15,1,0):[]]
zipWith3(g, lst1, lst2, lst3);    // => [12:13:14:15:16:[]]</code></pre>



        
    

    

    
</article>

</section>







<section>

<header>
    
        
    
</header>

<article>
    <div class="container-overview">
    
        

        
    
    </div>

    

    

    

     

    

    

    
        <h3 class="subsection-title">Methods</h3>

        
            

    

    <h4 class="name" id=".insert"><span class="type-signature">(static) </span>insert<span class="signature">(e, xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>The <code>insert</code> function takes an element and a <code>List</code> and inserts the element into the list at the
first position where it is less than or equal to the next element. In particular, if the list is
sorted before the call, the result will also be sorted. Use <code>insertBy</code> to supply your own
comparison function.
<br><code>Haskell&gt; insert :: Ord a =&gt; a -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>e</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The element to insert</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to insert into</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line174">line 174</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new <code>List</code>, with the element inserted</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst = list(1,2,3,4,5,6,8,9,10);
insert(7, lst); // => [1:2:3:4:5:6:7:8:9:10:[]]</code></pre>



        
            

    

    <h4 class="name" id=".insertBy"><span class="type-signature">(static) </span>insertBy<span class="signature">(cmp, e, as)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Insert an element into a list using a comparison function of your choice.
<br><code>Haskell&gt; insertBy :: (a -&gt; a -&gt; Ordering) -&gt; a -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>cmp</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The comparison function—must return an <code>Ordering</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>e</code></td>
            

            <td class="type">
            
                
<span class="param-type">*</span>


            
            </td>

            

            

            <td class="description last"><p>The element to insert</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to insert into</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line192">line 192</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>A new <code>List</code>, with the element inserted</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const notCompare = (x, y) => compare(x, y) === EQ ? EQ : (GT ? LT : GT);
const lst = list(1,2,3,4,5,6,8,9,10);
insertBy(notCompare, 7, lst); // => [7:1:2:3:4:5:6:8:9:10:[]]</code></pre>



        
            

    

    <h4 class="name" id=".mergeSort"><span class="type-signature">(static) </span>mergeSort<span class="signature">(xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using regular value comparison. Use <code>mergeSortBy</code> to supply your own comparison
function. Uses a merge sort algorithm, which may be more efficient than <code>sort</code> for larger lists.
<br><code>Haskell&gt; sort :: Ord a =&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line86">line 86</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <ul>
<li>The sorted <code>List</code> (the original list is unmodified)</li>
</ul>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(20,19,18,17,16,15,14,13,12,11,10,1,2,3,4,5,6,7,8,9);
mergeSort(lst1); // => [1:2:3:4:5:6:7:8:9:10:11:12:13:14:15:16:17:18:19:20:[]]
const f = x => x + 1;
const lst2 = reverse(listRange(1, 11, f)); // [10:9:8:7:6:5:4:3:2:1:[]]
mergeSort(lst2);                           // => [1:2:3:4:5:6:7:8:9:10:[]]</code></pre>



        
            

    

    <h4 class="name" id=".mergeSortBy"><span class="type-signature">(static) </span>mergeSortBy<span class="signature">(cmp, as)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using a comparison function of your choice. Uses a merge sort algorithm, which may be
more efficient than <code>sortBy</code> for larger lists.
<br><code>Haskell&gt; sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>cmp</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The comparison function—must return an <code>Ordering</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line104">line 104</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The sorted <code>List</code> (the original list is unmodified)</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const notCompare = (x, y) => compare(x, y) === EQ ? EQ : (GT ? LT : GT);
const lst1 = listRange(1, 11);
const lst2 = reverse(lst1);    // [10:9:8:7:6:5:4:3:2:1:[]]
mergeSortBy(notCompare, lst1); // => [1:2:3:4:5:6:7:8:9:10:[]]
mergeSortBy(notCompare, lst2); // => [10:9:8:7:6:5:4:3:2:1:[]]</code></pre>



        
            

    

    <h4 class="name" id=".sort"><span class="type-signature">(static) </span>sort<span class="signature">(xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using regular value comparison. Use <code>sortBy</code> to supply your own comparison function.
Uses an insertion sort algorithm. The <code>mergeSort</code> function is probably more efficient for larger
lists.
<br><code>Haskell&gt; sort :: Ord a =&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line49">line 49</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The sorted <code>List</code> (the original list is unmodified)</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst = list(9,8,7,6,5,4,3,10,13,11,14,23,24,26,25,2,1);
sort(lst); // => [1:2:3:4:5:6:7:8:9:10:11:13:14:23:24:25:26:[]]</code></pre>



        
            

    

    <h4 class="name" id=".sortBy"><span class="type-signature">(static) </span>sortBy<span class="signature">(cmp, xs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Sort a list using a comparison function of your choice. Uses an insertion sort algorithm. The
<code>mergeSortBy</code> function is probably more efficient for larger lists.
<br><code>Haskell&gt; sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>cmp</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The comparison function—must return an <code>Ordering</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>xs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The <code>List</code> to sort</p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_ordering.js.html">list/ordering.js</a>, <a href="list_ordering.js.html#line66">line 66</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The sorted <code>List</code> (the original list is unmodified)</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const notCompare = (x, y) => compare(x, y) === EQ ? EQ : (GT ? LT : GT);
const lst1 = listRange(1, 11);
const lst2 = reverse(lst1);    // [10:9:8:7:6:5:4:3:2:1:[]]
sortBy(notCompare, lst1);      // => [1:2:3:4:5:6:7:8:9:10:[]]
sortBy(notCompare, lst2);      // => [10:9:8:7:6:5:4:3:2:1:[]]</code></pre>



        
            

    

    <h4 class="name" id=".zip"><span class="type-signature">(static) </span>zip<span class="signature">(as, bs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Take two <code>List</code> objects and return a <code>List</code> of corresponding pairs. If one input list is shorter,
excess elements of the longer list are discarded.
<br><code>Haskell&gt; zip :: [a] -&gt; [b] -&gt; [(a, b)]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line41">line 41</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code> of <code>Tuple</code> objects</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
zip(lst1, lst2);              // => [(1,5):(2,4):(3,3):(4,2):(5,1):[]]</code></pre>



        
            

    

    <h4 class="name" id=".zip3"><span class="type-signature">(static) </span>zip3<span class="signature">(as, bs, cs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>Take three <code>List</code> objects and return a <code>List</code> of triples (<code>Tuple</code> objects with three values).
Analogous to the <code>zip</code> function.
<br><code>Haskell&gt; zip3 :: [a] -&gt; [b] -&gt; [c] -&gt; [(a, b, c)]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>cs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The third <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line71">line 71</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code> of <code>Tuple</code> objects</p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
const lst3 = list(6,7,8,9,10);
zip3(lst1, lst2, lst3);        // => [(1,5,6):(2,4,7):(3,3,8):(4,2,9):(5,1,10):[]]</code></pre>



        
            

    

    <h4 class="name" id=".zipWith"><span class="type-signature">(static) </span>zipWith<span class="signature">(f, as, bs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>A generalization of the <code>zip</code> function. Zip two <code>List</code> objects using a provided function.
<br><code>Haskell&gt; zipWith :: (a -&gt; b -&gt; c) -&gt; [a] -&gt; [b] -&gt; [c]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The zipping function</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line104">line 104</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code></p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
const f = (x, y) => tuple(x * 3, y ** 2);
const g = (x, y) => x + y;
zipWith(f, lst1, lst2);                   // => [(3,25):(6,16):(9,9):(12,4):(15,1):[]]
zipWith(g, lst1, lst2);                   // => [6:6:6:6:6:[]]</code></pre>



        
            

    

    <h4 class="name" id=".zipWith3"><span class="type-signature">(static) </span>zipWith3<span class="signature">(f, as, bs, cs)</span><span class="type-signature"> &rarr; {List}</span></h4>

    



<div class="description">
    <p>A generalization of the <code>zip3</code> function. Zip three <code>List</code> objects using a provided function.
<br><code>Haskell&gt; zipWith3 :: (a -&gt; b -&gt; c -&gt; d) -&gt; [a] -&gt; [b] -&gt; [c] -&gt; [d]</code></p>
</div>









    <h5>Parameters:</h5>
    

<table class="params">
    <thead>
    <tr>
        
        <th>Name</th>
        

        <th>Type</th>

        

        

        <th class="last">Description</th>
    </tr>
    </thead>

    <tbody>
    

        <tr>
            
                <td class="name"><code>f</code></td>
            

            <td class="type">
            
                
<span class="param-type">function</span>


            
            </td>

            

            

            <td class="description last"><p>The zipping function</p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>as</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The first <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>bs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The second <code>List</code></p></td>
        </tr>

    

        <tr>
            
                <td class="name"><code>cs</code></td>
            

            <td class="type">
            
                
<span class="param-type">List</span>


            
            </td>

            

            

            <td class="description last"><p>The third <code>List</code></p></td>
        </tr>

    
    </tbody>
</table>






<dl class="details">

    

    

    

    

    

    

    

    

    

    

    

    

    
    <dt class="tag-source">Source:</dt>
    <dd class="tag-source"><ul class="dummy"><li>
        <a href="list_zip.js.html">list/zip.js</a>, <a href="list_zip.js.html#line136">line 136</a>
    </li></ul></dd>
    

    

    

    
</dl>













<h5>Returns:</h5>

        
<div class="param-desc">
    <p>The zipped <code>List</code></p>
</div>



<dl>
    <dt>
        Type
    </dt>
    <dd>
        
<span class="param-type">List</span>


    </dd>
</dl>

    


    <h5>Example</h5>
    
    <pre class="prettyprint"><code>const lst1 = list(1,2,3,4,5);
const lst2 = list(5,4,3,2,1);
const lst3 = list(6,7,8,9,10);
const f = (x, y, z) => tuple(x * 3, y * y, z % 2);
const g = (x, y, z) => x + y + z;
zipWith3(f, lst1, lst2, lst3);    // => [(3,25,0):(6,16,1):(9,9,0):(12,4,1):(15,1,0):[]]
zipWith3(g, lst1, lst2, lst3);    // => [12:13:14:15:16:[]]</code></pre>



        
    

    

    
</article>

</section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-applicative.html">applicative</a></li><li><a href="module-base_bool.html">base/bool</a></li><li><a href="module-base_io.html">base/io</a></li><li><a href="module-base_misc.html">base/misc</a></li><li><a href="module-base_num.html">base/num</a></li><li><a href="module-eq.html">eq</a></li><li><a href="module-error.html">error</a></li><li><a href="module-foldable.html">foldable</a></li><li><a href="module-functor.html">functor</a></li><li><a href="module-list_building.html">list/building</a></li><li><a href="module-list_folds.html">list/folds</a></li><li><a href="module-list_func.html">list/func</a></li><li><a href="module-list_indexing.html">list/indexing</a></li><li><a href="module-list_inf.html">list/inf</a></li><li><a href="module-list_reducing.html">list/reducing</a></li><li><a href="module-list_searching.html">list/searching</a></li><li><a href="module-list_set.html">list/set</a></li><li><a href="module-list_sub.html">list/sub</a></li><li><a href="module-list_trans.html">list/trans</a></li><li><a href="module-list_zip.html">list/zip</a></li><li><a href="module-maybe_func.html">maybe/func</a></li><li><a href="module-monad.html">monad</a></li><li><a href="module-monoid.html">monoid</a></li><li><a href="module-ord.html">ord</a></li><li><a href="module-traversable.html">traversable</a></li><li><a href="module-tuple_func.html">tuple/func</a></li><li><a href="module-type.html">type</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.0</a> on Thu Jul 21 2016 17:04:18 GMT-0400 (EDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>